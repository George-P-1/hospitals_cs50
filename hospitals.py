"""
Project Description
-------------------

The project aims to visualize the state-space landscape of cost function for the case of optimization of distance to houses at the presence of one hospital only.
Expected result from the project:
After running the code, beside seeing a grid map of the houses and hospital originally generated by the project as images, project must generate a heat grid map (2d or 3d) as python graph like visualization or image like visualization of the same grid size of houses and hospital, the value of "Heat" in case of 2d graph or Z value in case of 3d Graph will be calculated as sum of Manhattan distances of that one hospital to all the houses.
Bonus:
As the original code tries to put a hospital randomly in one place in the map and use hill climb algorithm to move to hospital around to minimize the cost, 
We can show the optimization process on the heat map, as a line segments connecting initial configuration of the hospital to final solution (local minima), however any other solution than line segment visualizing the optimization process on heatmap is acceptable

"""

import random
import time
import os
import numpy as np
import matplotlib.pyplot as plt

# Save in new folder for each run
timestamp = time.strftime("%Y-%m-%d_%H-%M-%S", time.localtime())
folder_name = f'img_{timestamp}'
os.makedirs(folder_name, exist_ok=True)

class Space():

    def __init__(self, height, width, num_hospitals):
        """Create a new state space with given dimensions."""
        self.height = height
        self.width = width
        self.num_hospitals = num_hospitals
        self.houses = set()
        self.hospitals = set()
        self.optimization_path = [] # for storing the optimization path

    def add_house(self, row, col):
        """Add a house at a particular location in state space."""
        self.houses.add((row, col))

    def available_spaces(self):
        """Returns all cells not currently used by a house or hospital."""

        # Consider all possible cells
        candidates = set(
            (row, col)
            for row in range(self.height)
            for col in range(self.width)
        )

        # Remove all houses and hospitals
        for house in self.houses:
            candidates.remove(house)
        for hospital in self.hospitals:
            candidates.remove(hospital)
            
        return candidates

    def hill_climb(self, maximum=None, image_prefix=None, log=False):
        """Performs hill-climbing to find a solution."""
        count = 0

        # Start by initializing hospitals randomly
        self.hospitals = set()
        for i in range(self.num_hospitals):
            self.hospitals.add(random.choice(list(self.available_spaces())))
        self.optimization_path.append(list(self.hospitals)[0]) # Append initial state to optimization path
        # The [0] is used to get the first hospital location from the set of hospitals

        if log:
            print("Initial state: cost", self.get_cost(self.hospitals))
        if image_prefix:
            self.output_image(f"{image_prefix}{str(count).zfill(3)}.png")

        # Continue until we reach maximum number of iterations
        while maximum is None or count < maximum:
            count += 1
            best_neighbors = []
            best_neighbor_cost = None

            # Consider all hospitals to move
            for hospital in self.hospitals:

                # Consider all neighbors for that hospital
                for replacement in self.get_neighbors(*hospital):

                    # Generate a neighboring set of hospitals
                    neighbor = self.hospitals.copy()
                    neighbor.remove(hospital)
                    neighbor.add(replacement)

                    # Check if neighbor is best so far
                    cost = self.get_cost(neighbor)
                    if best_neighbor_cost is None or cost < best_neighbor_cost:
                        best_neighbor_cost = cost
                        best_neighbors = [neighbor]
                    elif best_neighbor_cost == cost:
                        best_neighbors.append(neighbor)

            # None of the neighbors are better than the current state
            if best_neighbor_cost >= self.get_cost(self.hospitals):
                return self.hospitals, self.optimization_path

            # Move to a highest-valued neighbor
            else:
                if log:
                    print(f"Found better neighbor: cost {best_neighbor_cost}")
                self.hospitals = random.choice(best_neighbors)
                self.optimization_path.append(list(self.hospitals)[0])  # Append best neighbour to optimization path

            # Generate image
            if image_prefix:
                self.output_image(f"{image_prefix}{str(count).zfill(3)}.png")

    def random_restart(self, maximum, image_prefix=None, log=False):
        """Repeats hill-climbing multiple times."""
        best_hospitals = None
        best_cost = None

        # Repeat hill-climbing a fixed number of times
        for i in range(maximum):
            hospitals = self.hill_climb()
            cost = self.get_cost(hospitals)
            if best_cost is None or cost < best_cost:
                best_cost = cost
                best_hospitals = hospitals
                if log:
                    print(f"{i}: Found new best state: cost {cost}")
            else:
                if log:
                    print(f"{i}: Found state: cost {cost}")

            if image_prefix:
                self.output_image(f"{image_prefix}{str(i).zfill(3)}.png")

        return best_hospitals

    def get_cost(self, hospitals):
        """Calculates sum of distances from houses to nearest hospital."""
        cost = 0
        for house in self.houses:
            cost += min(
                abs(house[0] - hospital[0]) + abs(house[1] - hospital[1])
                for hospital in hospitals
            )

        return cost

    def get_neighbors(self, row, col):
        """Returns neighbors not already containing a house or hospital."""
        candidates = [
            (row - 1, col),
            (row + 1, col),
            (row, col - 1),
            (row, col + 1)
        ]
        neighbors = []
        for r, c in candidates:
            if (r, c) in self.houses or (r, c) in self.hospitals:
                continue
            # Check if neighbor is within bounds of the grid
            if 0 <= r < self.height and 0 <= c < self.width:
                neighbors.append((r, c))

        return neighbors

    def output_image(self, filename, initial=False):
        """Generates image with all houses and hospitals."""
        from PIL import Image, ImageDraw, ImageFont
        cell_size = 100
        cell_border = 2
        # next 2 values are for adding the cost as text at the bottom of the image
        cost_size = 40
        padding = 10

        # Create a blank canvas
        img = Image.new(
            "RGBA",
            (self.width * cell_size,
             self.height * cell_size + cost_size + padding * 2),
            "white"
        )
        house = Image.open("assets/images/House.png").resize(
            (cell_size, cell_size)
        )
        hospital = Image.open("assets/images/Hospital.png").resize(
            (cell_size, cell_size)
        )
        font = ImageFont.truetype("assets/fonts/OpenSans-Regular.ttf", 30)
        draw = ImageDraw.Draw(img)

        for i in range(self.height):
            for j in range(self.width):

                # Draw cell
                rect = [
                    (j * cell_size + cell_border,
                     i * cell_size + cell_border),
                    ((j + 1) * cell_size - cell_border,
                     (i + 1) * cell_size - cell_border)
                ]
                draw.rectangle(rect, fill="black")

                # Draw house or hospital if present into the respective cell in the canvas
                if (i, j) in self.houses:
                    img.paste(house, rect[0], house)
                if (i, j) in self.hospitals:
                    img.paste(hospital, rect[0], hospital)

        # Add cost
        draw.rectangle(
            (0, self.height * cell_size, 
             self.width * cell_size, self.height * cell_size + cost_size + padding * 2),
            fill="#1f110b"
        )
        # Because this function is being called from outside the class and it does not have access to the class variables
        if not initial:
            draw.text(
                (padding, self.height * cell_size + padding),
                f"Cost: {self.get_cost(self.hospitals)}",
                fill="white",
                font=font
            )

        filename = f'{folder_name}/{filename}'
        img.save(filename)

    # New Methods for generating heatmap
    def add_hospital(self): # REMOVE_LATER - It is just not needed at all since hill_climb is already generating random hospital location
        """Add a hospital at a random location in state space."""
        self.hospital = random.choice(list(self.available_spaces()))

    def calc_manhattan_distance(self, hospital, house):
        """Calculate the Manhattan distance between a hospital and a house."""
        return abs(house[0] - hospital[0]) + abs(house[1] - hospital[1])

    def generate_heatmap(self):
        """Generate a heatmap based on manhattan distance from houses to hospital."""
        # Initialize heatmap
        heatmap = np.zeros((self.height, self.width))

        # Calculate cost for each cell. Iterate over each cell in the grid assuming hospital is placed there.
        for i in range(self.height):
            for j in range(self.width):
                heatmap[i, j] = sum(self.calc_manhattan_distance((i, j), house) for house in self.houses)

        return heatmap
    

def plot_heatmap(heatmap, colormap='hot', marker_color='blue', show_locations=False):
    """Plot a heatmap using matplotlib."""
    plt.imshow(heatmap, cmap=colormap, interpolation='nearest')
    plt.title("Heatmap of Manhattan distances to Houses")
    plt.colorbar(label="Manhattan Distance", orientation="vertical")
    plt.xticks([])  # Hide x-axis ticks
    plt.yticks([])  # Hide y-axis ticks
    plt.tight_layout()
    plt.savefig(f'{folder_name}/heatmap_raw.png')
    # Show houses and hospital on the heatmap
    if show_locations:
        for house in s.houses:
            plt.text(house[1], house[0], '*', ha='center', va='center', fontsize=12, color=marker_color)
    plt.title("Heatmap of Manhattan distances to Houses\n[House=* and Optimal Hospital=x]")
    # TODO - Bonus part: Show the optimization process on the heatmap
    # plt.show() # REMOVE_LATER

    return plt.gcf()

def plot_optimization_process(optimization_path, marker_color='blue'):
    """Plot the optimization process on the heatmap."""
    # Plot line from initial hospital to next step in optimization process and so on all the way to to final hospital
    # for now plot a + sign at every step of hospital movement
    x = [hospital_state[1] for hospital_state in optimization_path]
    y = [hospital_state[0] for hospital_state in optimization_path]
    plt.plot(x, y, '-', color=marker_color)
    plt.plot(x[0], y[0], '>', color=marker_color, label='Initial Hospital')
    plt.plot(x[-1], y[-1], 'x', color=marker_color, label='Final Hospital')
    plt.savefig(f'{folder_name}/heatmap_optimization.png')
    plt.show()


# Create a new space and add houses randomly
s = Space(height=10, width=20, num_hospitals=1)
for i in range(15):
    s.add_house(random.randrange(s.height), random.randrange(s.width))

# Output the map of houses only
s.output_image(f"houses_map.png", True)

# Choose a random hospital location
# s.add_hospital() # REMOVE_LATER - because hill_climb is already generating random hospital location

# Generate heatmap
heatmap = s.generate_heatmap()

# Plot heatmap
# Choose random colormap
plot_colors = random.choice([["viridis", "red"], ["plasma", "black"], ["hot", "green"]])
# plot_colors = ["plasma", "black"] # REMOVE_LATER - uncomment above line
fig = plot_heatmap(heatmap, plot_colors[0], plot_colors[1], True)

# Use local search to determine hospital placement
hospitals, op_path = s.hill_climb(image_prefix="hospitals", log=True)

print(hospitals)
print(op_path)

plot_optimization_process(op_path, plot_colors[1])

# Using random restart to find the global maxima in case of multiple local minima
# hospitals = s.random_restart(20, image_prefix="hospitals", log=True)
